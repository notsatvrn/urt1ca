// Port of "exploit_utilities" from Jake James' sock_port and time_waste.

const mach = @cImport(@cInclude("mach/mach.h"));

//const utils = @import("../utils.zig");

pub fn newMachPort() mach.mach_port_t {
    var port = mach.MACH_PORT_NULL;
    var ret = mach.mach_port_allocate(
        mach.mach_task_self(),
        mach.MACH_PORT_RIGHT_RECEIVE,
        @ptrCast([*c]mach.mach_port_t, &port),
    );
    if (ret) {
        //utils.error("failed to allocate port", .{});
        return mach.MACH_PORT_NULL;
    }
    ret = mach.mach_port_insert_right(
        mach.mach_task_self(),
        port,
        port,
        mach.MACH_MSG_TYPE_MAKE_SEND,
    );
    if (ret) {
        //utils.error("failed to insert right", .{});
        mach.mach_port_destroy(mach.mach_task_self(), port);
        return mach.MACH_PORT_NULL;
    }
    var limits = mach.mach_port_limits_t {0};
    limits.mpl_qlimit = mach.MACH_PORT_QLIMIT_LARGE;
    ret = mach.mach_port_set_attributes(
        mach.mach_task_self(),
        port,
        mach.MACH_PORT_LIMITS_INFO,
        @ptrCast(mach.mach_port_info_t, &limits),
        mach.MACH_PORT_LIMITS_INFO_COUNT,
    );
    if (ret) {
        //utils.error("failed to increase queue limit", .{});
        mach.mach_port_destroy(mach.mach_task_self(), port);
        return mach.MACH_PORT_NULL;
    }
    return port;
}

pub fn messageSizeForKallocSize(kalloc_size: usize) usize {
    return ((3 * kalloc_size) / 4) - 0x74;
}
