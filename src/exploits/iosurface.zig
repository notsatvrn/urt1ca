// Port of Brandon Azad's IOSurface Definitions.

const c = @cImport({
    @cInclude("mach/mach.h");
    @cInclude("iokit.h");
});

const utils = @import("../utils.zig");
const std = @import("std");

pub const MAX_IOSURFACE_PROPERTY_INDEX = 0x00fd02fe;

pub const _FastCreateArgs = extern struct {
    address: u64,
    width: u32,
    height: u32,
    pixel_format: u32,
    bytes_per_element: u32,
    bytes_per_row: u32,
    alloc_size: u32,
};

pub const LockResult = extern struct {
	_pad1: [0x18]u8,
	surface_id: u32,
	_pad2: [0xdd0-0x18-0x4]u8,
};

pub const ValueArgs = extern struct {
    surface_id: u32,
    field_4: u32,
    data: union {
        xml: [0]u32,
        string: [0]u8,
    },
};

pub const ValueResultArgs = extern struct {
    field_0: u32,
};

pub var root: c.mach_port_t = 0;
pub var rootUserClient: c.mach_port_t = 0;
pub var id: u32 = 0;
pub var initialized = false;

pub fn init() bool {
    if (initialized) {
        return true;
    }

    root = c.IOServiceGetMatchingService(
        c.kIOMasterPortDefault,
        c.IOServiceMatching("Root"),
    );
    if (root == c.MACH_PORT_NULL) {
        utils.errorf("could not find IOSurface root", .{});
        return false;
    }

    var err = c.IOServiceOpen(
        root,
        c.mach_task_self(),
        0,
        &rootUserClient,
    );
    if (err) {
        utils.errorf("could not find IOSurface rootUserClient: 0x{x}.", .{err});
        return false;
    }

    var create_args = _FastCreateArgs { .alloc_size = c.page_size };
    var lock_result = LockResult{};
    var lock_result_size = @sizeOf(lock_result);

    err = c.IOConnectCallMethod(
        rootUserClient,
        6,
        null, 0,
        &create_args, @sizeOf(create_args),
        null, null,
        &lock_result, &lock_result_size,
    );
    if (err) {
        utils.errorf("could not create IOSurface client: 0x{x}.", .{err});
        return false;
    }

    id = lock_result.surface_id;
    initialized = true;
    return true;
}

pub fn deinit() void {
    if (initialized) {
        c.IOServiceClose(rootUserClient);
        c.IOObjectRelease(root);
        initialized = false;
        id = 0;
    }
}

pub fn setValue(args: *ValueArgs, args_size: usize) bool {
    var result = ValueResultArgs{};
    var result_size = @sizeOf(result);
    var err = c.IOConnectCallMethod(
        rootUserClient,
        9,
        null, 0,
        args, @sizeOf(args) + args_size,
        null, null,
        &result, &result_size,
    );
    if (err) {
        utils.errorf("failed to set value in IOSurface: 0x{x}.", .{err});
        return false;
    }
    return true;
}

pub fn getValue(
    in: *ValueArgs, in_size: usize,
    out: *ValueArgs, out_size: *usize,
) bool {
    var err = c.IOConnectCallMethod(
        rootUserClient,
        9,
        null, 0,
        in, @sizeOf(in) + in_size,
        null, null,
        out, @sizeOf(out) + out_size,
    );
    if (err) {
        utils.errorf("failed to get value in IOSurface: 0x{x}.", .{err});
        return false;
    }
    return true;
}

pub fn removeValue(args: *ValueArgs, args_size: usize) bool {
    var result = ValueResultArgs{};
    var result_size = @sizeOf(result);
    var err = c.IOConnectCallMethod(
        rootUserClient,
        11,
        null, 0,
        args, @sizeOf(args) + args_size,
        null, null,
        &result, &result_size,
    );
    if (err) {
        utils.errorf("failed to remove value in IOSurface: 0x{x}.", .{err});
        return false;
    }
    return true;
}

pub fn base255Encode(value: u32) u32 {
    var encoded = 0;
    var i: usize = 0;
    while (i < @sizeOf(value)) : (i += 1) {
        encoded |= ((value % 255) + 1) << (8 * i);
        value /= 255;
    }
    return encoded;
}

pub fn propertyKey(index: u32) u32 {
    if (index <= MAX_IOSURFACE_PROPERTY_INDEX) {
        var encoded = base255Encode(index);
        if ((encoded >> 24) == 0x01) {
            return encoded & ~0xff000000;
        }
    }
    return 0;
}
